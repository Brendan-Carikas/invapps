{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport { cloneDeep, uniqBy } from 'lodash';\nimport { getNodeMaxSize } from './text';\n// 数据转换：原始节点数据 -> G6渲染节点数据\nvar transformOriginNodes = function (originNodes, layerOrder, size) {\n  // 过滤得到节点中实际存在的有效层级\n  var effectiveLayer = Array.isArray(layerOrder) && layerOrder.filter(function (layerName) {\n    return originNodes.find(function (node) {\n      return node.layerName === layerName;\n    });\n  }) || [];\n  return originNodes.map(function (originNode) {\n    var layer = (effectiveLayer === null || effectiveLayer === void 0 ? void 0 : effectiveLayer.findIndex(function (item) {\n      return item === originNode.layerName;\n    })) + 1; // dagre布局指定层级有bug，layer暂时从1开始\n    return {\n      id: originNode.id,\n      label: originNode.name || '',\n      layer: layer !== -1 ? layer : undefined,\n      style: __assign({\n        stroke: '#B8C3D9',\n        textColor: '#000'\n      }, originNode.style || {}),\n      size: size,\n      custom: {\n        layerName: originNode.layerName,\n        measure: originNode.measure,\n        relatedMeasures: originNode.relatedMeasures,\n        compareMeasures: originNode.compareMeasures // 同环比指标\n      },\n      data: cloneDeep(originNode),\n      x: originNode.x,\n      y: originNode.y\n    };\n  });\n};\n// 数据转换：原始边数据 -> G6渲染边数据\nvar transformOriginEdges = function (data, layerOrder, segmLayer, ratioMethod) {\n  var _a = data.nodes,\n    originNodes = _a === void 0 ? [] : _a,\n    _b = data.edges,\n    originEdges = _b === void 0 ? [] : _b;\n  return originEdges.map(function (originEdge) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    var sourceNode = originNodes.find(function (node) {\n      return node.id === originEdge.source;\n    });\n    var targetNode = originNodes.find(function (node) {\n      return node.id === originEdge.target;\n    });\n    if (!sourceNode || !targetNode) {\n      return undefined;\n    }\n    // 自动计算边的比率和名称\n    var autoRatio = 0;\n    var name = '';\n    switch (ratioMethod) {\n      case 'both':\n        // 包含占比和分流\n        // 找出分段层级的层级值\n        var segmLayerValue = layerOrder.findIndex(function (item) {\n          return item === segmLayer;\n        });\n        // 找出终点的层级值\n        var targetLayerValue = layerOrder.findIndex(function (item) {\n          return item === (targetNode === null || targetNode === void 0 ? void 0 : targetNode.layerName);\n        });\n        // 同层级的边、分段层级的入边都是占比边, 比率 = 边上指标 / 终点的主指标\n        if (!segmLayer || targetLayerValue <= segmLayerValue) {\n          autoRatio = ((_a = originEdge === null || originEdge === void 0 ? void 0 : originEdge.measure) === null || _a === void 0 ? void 0 : _a.value) / ((_b = targetNode === null || targetNode === void 0 ? void 0 : targetNode.measure) === null || _b === void 0 ? void 0 : _b.value);\n          name = '占比';\n        } else {\n          // 分段层级的出边都是分流边, 比率 = 边上指标 / 起点的主指标\n          autoRatio = ((_c = originEdge === null || originEdge === void 0 ? void 0 : originEdge.measure) === null || _c === void 0 ? void 0 : _c.value) / ((_d = sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.measure) === null || _d === void 0 ? void 0 : _d.value);\n          name = '分流';\n        }\n        break;\n      case 'splitFlow':\n        // 均是分流：比率 = 边上指标 / 起点的主指标\n        autoRatio = ((_e = originEdge === null || originEdge === void 0 ? void 0 : originEdge.measure) === null || _e === void 0 ? void 0 : _e.value) / ((_f = sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.measure) === null || _f === void 0 ? void 0 : _f.value);\n        name = '分流';\n        break;\n      case 'proportion':\n        // 均是占比：比率 = 边上指标 / 终点的主指标\n        autoRatio = ((_g = originEdge === null || originEdge === void 0 ? void 0 : originEdge.measure) === null || _g === void 0 ? void 0 : _g.value) / ((_h = targetNode === null || targetNode === void 0 ? void 0 : targetNode.measure) === null || _h === void 0 ? void 0 : _h.value);\n        name = '占比';\n        break;\n      default:\n        // 不展示转化比率\n        autoRatio = undefined;\n        name = '';\n        break;\n    }\n    var ratio = originEdge.ratio || autoRatio; // 优先使用edge数据里的ratio\n    var formatRatio = !isNaN(ratio) && ratio !== Infinity ? Number((ratio * 100).toString().match(/^\\d+(?:\\.\\d{0,2})?/)) : '-'; // 比率最多保留2位小数\n    var showRatio = \"\".concat(formatRatio, \"%\");\n    var label = originEdge.name || name; // 优先使用edge数据里的name\n    return {\n      id: originEdge.id,\n      source: originEdge.source,\n      target: originEdge.target,\n      label: autoRatio !== undefined ? \"\".concat(label, \" \").concat(showRatio) : '',\n      style: __assign({\n        stroke: '#B8C3D9',\n        labelFill: '#000',\n        highlightColor: '#3572F9'\n      }, originEdge.style || {}),\n      custom: {\n        ratio: ratio,\n        formatRatio: formatRatio,\n        showRatio: showRatio,\n        sourceNode: sourceNode,\n        targetNode: targetNode,\n        label: label\n      },\n      data: cloneDeep(originEdge)\n    };\n  }).filter(function (edge) {\n    return !!edge;\n  });\n};\n// 数据转换：原始数据 -> G6渲染数据\nexport var transformOriginData = function (originData, layerOrder, segmLayer, ratioMethod) {\n  if (layerOrder === void 0) {\n    layerOrder = [];\n  }\n  var _a = originData.nodes,\n    originNodes = _a === void 0 ? [] : _a;\n  // 节点去重\n  var uniqNodes = uniqBy(originNodes, 'id');\n  // 获取所有节点中最大的宽作为节点size\n  var size = getNodeMaxSize(uniqNodes);\n  var nodes = transformOriginNodes(uniqNodes, layerOrder, size);\n  var edges = transformOriginEdges(originData, layerOrder, segmLayer, ratioMethod);\n  return {\n    nodes: nodes,\n    edges: edges\n  };\n};","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","cloneDeep","uniqBy","getNodeMaxSize","transformOriginNodes","originNodes","layerOrder","size","effectiveLayer","Array","isArray","filter","layerName","find","node","map","originNode","layer","findIndex","item","id","label","name","undefined","style","stroke","textColor","custom","measure","relatedMeasures","compareMeasures","data","x","y","transformOriginEdges","segmLayer","ratioMethod","_a","nodes","_b","edges","originEdges","originEdge","_c","_d","_e","_f","_g","_h","sourceNode","source","targetNode","target","autoRatio","segmLayerValue","targetLayerValue","value","ratio","formatRatio","isNaN","Infinity","Number","toString","match","showRatio","concat","labelFill","highlightColor","edge","transformOriginData","originData","uniqNodes"],"sources":["/Users/invotradesign/CascadeProjects/site-users-app/node_modules/@ant-design/graphs/es/components/conversion-dagre-graph/utils/transform.js"],"sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { cloneDeep, uniqBy } from 'lodash';\nimport { getNodeMaxSize } from './text';\n// 数据转换：原始节点数据 -> G6渲染节点数据\nvar transformOriginNodes = function (originNodes, layerOrder, size) {\n    // 过滤得到节点中实际存在的有效层级\n    var effectiveLayer = (Array.isArray(layerOrder) &&\n        layerOrder.filter(function (layerName) { return originNodes.find(function (node) { return node.layerName === layerName; }); })) ||\n        [];\n    return originNodes.map(function (originNode) {\n        var layer = (effectiveLayer === null || effectiveLayer === void 0 ? void 0 : effectiveLayer.findIndex(function (item) { return item === originNode.layerName; })) + 1; // dagre布局指定层级有bug，layer暂时从1开始\n        return {\n            id: originNode.id,\n            label: originNode.name || '',\n            layer: layer !== -1 ? layer : undefined,\n            style: __assign({ stroke: '#B8C3D9', textColor: '#000' }, (originNode.style || {})),\n            size: size,\n            custom: {\n                layerName: originNode.layerName,\n                measure: originNode.measure,\n                relatedMeasures: originNode.relatedMeasures,\n                compareMeasures: originNode.compareMeasures, // 同环比指标\n            },\n            data: cloneDeep(originNode),\n            x: originNode.x,\n            y: originNode.y,\n        };\n    });\n};\n// 数据转换：原始边数据 -> G6渲染边数据\nvar transformOriginEdges = function (data, layerOrder, segmLayer, ratioMethod) {\n    var _a = data.nodes, originNodes = _a === void 0 ? [] : _a, _b = data.edges, originEdges = _b === void 0 ? [] : _b;\n    return originEdges\n        .map(function (originEdge) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        var sourceNode = originNodes.find(function (node) { return node.id === originEdge.source; });\n        var targetNode = originNodes.find(function (node) { return node.id === originEdge.target; });\n        if (!sourceNode || !targetNode) {\n            return undefined;\n        }\n        // 自动计算边的比率和名称\n        var autoRatio = 0;\n        var name = '';\n        switch (ratioMethod) {\n            case 'both':\n                // 包含占比和分流\n                // 找出分段层级的层级值\n                var segmLayerValue = layerOrder.findIndex(function (item) { return item === segmLayer; });\n                // 找出终点的层级值\n                var targetLayerValue = layerOrder.findIndex(function (item) { return item === (targetNode === null || targetNode === void 0 ? void 0 : targetNode.layerName); });\n                // 同层级的边、分段层级的入边都是占比边, 比率 = 边上指标 / 终点的主指标\n                if (!segmLayer || targetLayerValue <= segmLayerValue) {\n                    autoRatio = ((_a = originEdge === null || originEdge === void 0 ? void 0 : originEdge.measure) === null || _a === void 0 ? void 0 : _a.value) / ((_b = targetNode === null || targetNode === void 0 ? void 0 : targetNode.measure) === null || _b === void 0 ? void 0 : _b.value);\n                    name = '占比';\n                }\n                else {\n                    // 分段层级的出边都是分流边, 比率 = 边上指标 / 起点的主指标\n                    autoRatio = ((_c = originEdge === null || originEdge === void 0 ? void 0 : originEdge.measure) === null || _c === void 0 ? void 0 : _c.value) / ((_d = sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.measure) === null || _d === void 0 ? void 0 : _d.value);\n                    name = '分流';\n                }\n                break;\n            case 'splitFlow':\n                // 均是分流：比率 = 边上指标 / 起点的主指标\n                autoRatio = ((_e = originEdge === null || originEdge === void 0 ? void 0 : originEdge.measure) === null || _e === void 0 ? void 0 : _e.value) / ((_f = sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.measure) === null || _f === void 0 ? void 0 : _f.value);\n                name = '分流';\n                break;\n            case 'proportion':\n                // 均是占比：比率 = 边上指标 / 终点的主指标\n                autoRatio = ((_g = originEdge === null || originEdge === void 0 ? void 0 : originEdge.measure) === null || _g === void 0 ? void 0 : _g.value) / ((_h = targetNode === null || targetNode === void 0 ? void 0 : targetNode.measure) === null || _h === void 0 ? void 0 : _h.value);\n                name = '占比';\n                break;\n            default:\n                // 不展示转化比率\n                autoRatio = undefined;\n                name = '';\n                break;\n        }\n        var ratio = originEdge.ratio || autoRatio; // 优先使用edge数据里的ratio\n        var formatRatio = !isNaN(ratio) && ratio !== Infinity ? Number((ratio * 100).toString().match(/^\\d+(?:\\.\\d{0,2})?/)) : '-'; // 比率最多保留2位小数\n        var showRatio = \"\".concat(formatRatio, \"%\");\n        var label = originEdge.name || name; // 优先使用edge数据里的name\n        return {\n            id: originEdge.id,\n            source: originEdge.source,\n            target: originEdge.target,\n            label: autoRatio !== undefined ? \"\".concat(label, \" \").concat(showRatio) : '',\n            style: __assign({ stroke: '#B8C3D9', labelFill: '#000', highlightColor: '#3572F9' }, (originEdge.style || {})),\n            custom: {\n                ratio: ratio,\n                formatRatio: formatRatio,\n                showRatio: showRatio,\n                sourceNode: sourceNode,\n                targetNode: targetNode,\n                label: label,\n            },\n            data: cloneDeep(originEdge),\n        };\n    })\n        .filter(function (edge) { return !!edge; });\n};\n// 数据转换：原始数据 -> G6渲染数据\nexport var transformOriginData = function (originData, layerOrder, segmLayer, ratioMethod) {\n    if (layerOrder === void 0) { layerOrder = []; }\n    var _a = originData.nodes, originNodes = _a === void 0 ? [] : _a;\n    // 节点去重\n    var uniqNodes = uniqBy(originNodes, 'id');\n    // 获取所有节点中最大的宽作为节点size\n    var size = getNodeMaxSize(uniqNodes);\n    var nodes = transformOriginNodes(uniqNodes, layerOrder, size);\n    var edges = transformOriginEdges(originData, layerOrder, segmLayer, ratioMethod);\n    return {\n        nodes: nodes,\n        edges: edges,\n    };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}